-- moduler library for splitting scripts into the modules and load them anywhere, with no need for changing the structure
-- Made by MahdiMz
-- https://github.com/MahdiMz80/Moduler
-- v2.2

--=================================
local useRuntimeMethod = false

------------------------------
-- Only for default method:

local forceKill = true
local sendThroughCommand = false
--=================================

local a=nil;function getLoaderPath()for b,c in pairs(script.list())do if c.name:lower()=="moduler"then return c.path end end;return false end;function loadModuler()local d=getWorkingDirectory().."\\lib\\moduler_loader.lua"if doesFileExist(d)then local e,f=pcall(function()script.load(d)end)if e then a=d end end end;if not useRuntimeMethod then a=getLoaderPath()if not a then loadModuler()end;assert(a,"Cannot load the moduler loader script.")end;local g={}function string:trim()return self:match("^%s*(.-)%s*$")end;function noExt(h)h=h:gsub("%.+",".")if h:lower():match("%.luac$")then h=h:sub(1,-6)elseif h:lower():match("%.lua$")then h=h:sub(1,-5)end;return h end;function printErr(i)print("{ff7070}(error): {c0c0c0}"..i)end;function extractSubmodule(j,k)j=j:gsub("\r\n","\n"):gsub("\r","\n")local l="%-%-%s*[Mm]oduler:%s*"..k.."%s*\n"local m,n=j:find("^"..l)if not m then m,n=j:find("\n"..l)end;if not m then return nil end;local o=n+1;local p=j:find("\n%-%-%s*[Mm]oduler:%s*[_%w]+%s*\n",o)local q=j:sub(o,p and p-1 or#j)q=q:gsub("^\n+",""):gsub("\n+$","")return q end;function findModulerCalls(r)local s={}local t={}local u=1;while true do local m=r:find("%-%-%[%[",u)if not m then break end;local p=r:find("%]%]",m+4)if p then table.insert(t,{s=m,e=p+1})u=p+2 else break end end;local function v(w)for x,y in ipairs(t)do if w>=y.s and w<=y.e then return true end end;return false end;for z,A in r:gmatch('(moduler%s*%(%s*["\']([^"\']+)["\']%s*%))')do local B=r:find(z,1,true)if B and not v(B)then local C=r:sub(1,B):match(".*\n()")or 1;local D=r:sub(C,B-1)if not D:match("^%s*%-%-")then local E=D:match('^([ \t]*)')table.insert(s,{module=A,indent=E or""})end end end;return s end;function applyIndentation(F,E)local G={}for H in(F.."\n"):gmatch("([^\r\n]*)\r?\n")do table.insert(G,H)end;if#G>0 then local I=nil;for x,H in ipairs(G)do if H:match("%S")then local J=H:match("^([ \t]*)")if not I or#J<#I then I=J end end end;if I and#I>0 then local K={}for x,H in ipairs(G)do if H:sub(1,#I)==I then table.insert(K,H:sub(#I+1))else table.insert(K,H)end end;G=K end end;if E==""then return table.concat(G,"\n")end;local L={}for x,H in ipairs(G)do table.insert(L,E..H)end;return table.concat(L,"\n")end;function build(M)M=noExt(M)local N=getWorkingDirectory()local O=N.."/moduler"local P=O.."/"..M;local Q=N.."/"..M..".lua"if not doesFileExist(Q)then printErr('Script "'..M..'.lua" not found')return false end;local R=io.open(Q,"rb")if not R then printErr("Error opening script: "..M)return false end;local S=R:read("*a")R:close()if#S==0 then printErr(string.format('Script "%s" is empty.',M))return false end;local T=S:sub(1,4)if not T then printErr("No header found in script: "..M)return false end;if T=="\27Lua"or T=="\27LJ"then printErr(string.format('Script "%s" not supported as it is compiled. Use plain lua script.',M))return false end;local U=findModulerCalls(S)if#U==0 then print('No moduler() calls found in "'..M..'"')return true end;print('{44bbff}Moduler: {c0c0c0}Building "'..M..'" with '..#U..' module calls...')g={}local V={}for x,W in ipairs(U)do local X,E=W.module,W.indent;local A=noExt(X)local k=nil;if A:match("%.",1,true)then local Y={}for w in A:gmatch("[^%.]+")do table.insert(Y,w)end;if#Y>2 then printErr("Submodule nesting too deep: "..X)return false end;A=Y[1]k=#Y==2 and Y[2]:trim()or nil end;local Z=P.."/"..A..".lua"if not doesFileExist(Z)then printErr(string.format('Module "%s" not found for script "%s"',A,M))return false end;local _=io.open(Z,"rb")if not _ then printErr(string.format('Error opening module "%s" for script "%s"',A,M))return false end;local j=_:read("*a")_:close()if#j==0 then printErr(string.format('Module "%s" for script "%s" is empty.',A,M))return false end;local a0=j:sub(1,4)if not a0 then printErr(string.format('No header found in module "%s" for script "%s"',A,M))return false end;if a0=="\27Lua"or a0=="\27LJ"then printErr(string.format('Module "%s" for script "%s" not supported as it is compiled. Use plain lua module.',A,M))return false end;local a1;if k then a1=extractSubmodule(j,k)if not a1 then printErr(string.format('Submodule "%s" not found in module "%s" for script "%s"',k,A,M))return false end else a1=j end;local a2,a3=loadstring(a1,"@"..A..(k and"."..k or""))if not a2 then printErr(string.format('Syntax error in "%s" for script "%s": %s',X,M,a3))return false end;local a4=applyIndentation(a1,E)table.insert(V,{marker='moduler%s*%(%s*["\']'..X:gsub("%.","%%%.")..'["\']%s*%)',code="--[[START OF MODULER: "..X.."]]\n"..a4:gsub("%%","%%%%").."\n"..E.."--[[END OF MODULER: "..X.."]]"})if not g[X]then g[X]=a1 end end;S=S:gsub('require%s*%(%s*["\']moduler["\']%s*%)','-- require("moduler") removed')for x,a5 in ipairs(V)do S=S:gsub(a5.marker,a5.code)end;local a6=O.."\\"..M.."_moduler.lua"local a7=io.open(a6,"wb")if not a7 then printErr("Error writing the built script: "..M)return false end;a7:write(S)a7:close()local a8,a9=loadstring(S,M..".lua")if not a8 then printErr(string.format('Syntax error in built script "%s": %s',M,a9))return false end;for X,aa in pairs(g)do local ab,ac=loadstring(aa,"@"..X)if ab then g[X]=ab else printErr(string.format('Syntax error in "%s": %s',X,ac))g[X]=nil end end;print(string.format("{44bbff}Moduler: {c0c0c0}Loaded %d modules/submodules for '%s'",(function()local ad=0;for x in pairs(g)do ad=ad+1 end;return ad end)(),M))return true end;function load(X)if not X or X==""then printErr("Invalid module path")return nil end;X=X:trim()local ae=g[X]if ae and type(ae)=="function"then return ae()else printErr(string.format('Module "%s" not found',X))return nil end end;local af=thisScript().name;if not af then error("Cannot get the name of the caller script.")end;_G.moduler=function()end;if useRuntimeMethod then local ag=build(af)if not ag then error("Failed to build the final script.")end;_G.moduler=load else local ah=thisScript()local F=""if sendThroughCommand then F=string.format([=[lua_thread.create(function()wait(100)sampProcessChatInput("/moduler ".."%s")thisScript():unload()end)]=],ah.name)else F=string.format([=[require'lib.moonloader'local a=import'%s'lua_thread.create(function()wait(100)a.load("%s")thisScript():unload()end)]=],a:gsub("\\","\\\\"),ah.name)end;local ai=os.tmpname().."_moduler_requestload.lua"local aj=io.open(ai,"wb")aj:write(F)aj:close()local e,f=pcall(function()script.load(ai)end)if forceKill then local ak,al=pcall(function()ah:unload()end)error("_FORCE_KILL_THE_SCRIPT_")else lua_thread.create(function()wait(1)local ak,al=pcall(function()ah:unload()end)end)end;_G.moduler=function(A)local ak,al=pcall(function()ah:unload()end)end end;return _G.moduler
