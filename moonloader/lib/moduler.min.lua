-- moduler library for splitting scripts into the modules and load them anywhere, with no need for changing the structure
-- Made by MahdiMz
-- https://github.com/MahdiMz80/Moduler
-- v2.0

--=================================
local useOldMethod = false

------------------------------
-- Only for old method:

local forceKill = true
local sendThroughCommand = false
--=================================

local a=nil;function getLoaderPath()for b,c in pairs(script.list())do if c.name:lower()=="moduler"then return c.path end end;return false end;function loadModuler()local d=getWorkingDirectory().."\\lib\\moduler_loader.lua"if doesFileExist(d)then local e,f=pcall(function()script.load(d)end)if e then a=d end end end;if useOldMethod then a=getLoaderPath()if not a then loadModuler()end;assert(a,"Cannot load the moduler loader script.")end;local g={}function string:trim()return self:match("^%s*(.-)%s*$")end;function noExt(h)h=h:gsub("%.+",".")if h:lower():match("%.luac$")then h=h:sub(1,-6)elseif h:lower():match("%.lua$")then h=h:sub(1,-5)end;return h end;function printErr(i)print("{ff7070}(error): {c0c0c0}"..i)end;function extractSubmodule(j,k)local l={"local%s+function%s+"..k.."%s*%b()","function%s+"..k.."%s*%b()","local%s+"..k.."%s*=%s*function%s*%b()",k.."%s*=%s*function%s*%b()"}local m;for n,o in ipairs(l)do m=j:find(o)if m then break end end;if not m then return nil end;local p=j:find("%b()",m)if not p then return nil end;local n,p=j:find("%b()",m)p=p+1;local q,r,s=m,0,false;while q<=#j do local t,u=j:match("^([%a_][%w_]*)()",q)if t then if t=="function"or t=="do"or t=="if"or t=="for"or t=="while"or t=="repeat"then r=r+1;if t=="function"then s=true end;q=u elseif t=="end"then if s then r=r-1;if r==0 then local v=j:sub(p,q-1):match("^[\r\n]*(.-)[ \t\r\n]*$")return v end end;q=u elseif t=="until"then r=r-1;q=u else q=u end else q=q+1 end end;return nil end;function findModulerCalls(w)local x={}local q=1;while true do local y,z,A=w:find('moduler%s*%(%s*["\']([^"\']+)["\']%s*%)',q)if not y then break end;local B=y;while B>1 and w:sub(B-1,B-1):match('[^\r\n]')do B=B-1 end;local C=w:sub(B)local D=C:match('^([ \t]*)')table.insert(x,{module=A,indent=D})q=z+1 end;return x end;function applyIndentation(E,D)local F={}for G in E:gmatch("[^\r\n]+")do table.insert(F,G)end;if#F>0 then local H=nil;for n,G in ipairs(F)do if G:match("%S")then local I=G:match("^([ \t]*)")if not H or#I<#H then H=I end end end;if H and#H>0 then local J={}for n,G in ipairs(F)do if G:sub(1,#H)==H then table.insert(J,G:sub(#H+1))else table.insert(J,G)end end;F=J end end;if D==""then return table.concat(F,"\n")end;local K={}for n,G in ipairs(F)do table.insert(K,D..G)end;return table.concat(K,"\n")end;function build(L)L=noExt(L)local M=getWorkingDirectory()local N=M.."/moduler"local O=N.."/"..L;local P=M.."/"..L..".lua"if not doesFileExist(P)then printErr('Script "'..L..'.lua" not found')return false end;local Q=io.open(P,"rb")if not Q then printErr("Error opening script: "..L)return false end;local R=Q:read("*a")Q:close()if#R==0 then printErr(string.format('Script "%s" is empty.',L))return false end;local S=R:sub(1,4)if not S then printErr("No header found in script: "..L)return false end;if S=="\27Lua"or S=="\27LJ"then printErr(string.format('Script "%s" not supported as it is compiled. Use plain lua script.',L))return false end;local T=findModulerCalls(R)if#T==0 then print('No moduler() calls found in "'..L..'"')return true end;print('{44bbff}Moduler: {c0c0c0}Building "'..L..'" with '..#T..' module calls...')g={}local U={}for n,V in ipairs(T)do local W,D=V.module,V.indent;local A=noExt(W)local k=nil;if A:match("%.",1,true)then local X={}for Y in A:gmatch("[^%.]+")do table.insert(X,Y)end;if#X>2 then printErr("Submodule nesting too deep: "..W)return false end;A=X[1]k=#X==2 and X[2]:trim()or nil end;local Z=O.."/"..A..".lua"if not doesFileExist(Z)then printErr(string.format('Module "%s" not found for script "%s"',A,L))return false end;local _=io.open(Z,"rb")if not _ then printErr(string.format('Error opening module "%s" for script "%s"',A,L))return false end;local j=_:read("*a")_:close()if#j==0 then printErr(string.format('Module "%s" for script "%s" is empty.',A,L))return false end;local a0=j:sub(1,4)if not a0 then printErr(string.format('No header found in module "%s" for script "%s"',A,L))return false end;if a0=="\27Lua"or a0=="\27LJ"then printErr(string.format('Module "%s" for script "%s" not supported as it is compiled. Use plain lua module.',A,L))return false end;local a1;if k then a1=extractSubmodule(j,k)if not a1 then printErr(string.format('Submodule "%s" not found in module "%s" for script "%s"',k,A,L))return false end else a1=j end;local a2,a3=loadstring(a1,"@"..A..(k and"."..k or""))if not a2 then printErr(string.format('Syntax error in "%s" for script "%s": %s',W,L,a3))return false end;local a4=applyIndentation(a1,D)table.insert(U,{marker='moduler%s*%(%s*["\']'..W:gsub("%.","%%%.")..'["\']%s*%)',code=string.format("--[[START OF MODULER: %s]]\n%s\n%s--[[END OF MODULER: %s]]",W,a4,D,W)})if not g[W]then g[W]=a1 end end;for n,a5 in ipairs(U)do R=R:gsub(a5.marker,a5.code)end;R=R:gsub('require%s*%(%s*["\']moduler["\']%s*%)','-- require("moduler") removed')local a6,a7=loadstring(R,L..".lua")if not a6 then printErr(string.format('Syntax error in built script "%s": %s',L,a7))return false end;local a8=N.."\\"..L.."_moduler.lua"local a9=io.open(a8,"wb")if not a9 then printErr("Error writing the built script: "..L)return false end;a9:write(R)a9:close()for W,aa in pairs(g)do local ab,ac=loadstring(aa,"@"..W)if ab then g[W]=ab else printErr(string.format('Syntax error in "%s": %s',W,ac))g[W]=nil end end;print(string.format("{44bbff}Moduler: {c0c0c0}Loaded %d modules/submodules for '%s'",(function()local ad=0;for n in pairs(g)do ad=ad+1 end;return ad end)(),L))return true end;function load(W)if not W or W==""then printErr("Invalid module path")return nil end;W=W:trim()local ae=g[W]if ae and type(ae)=="function"then return ae()else printErr(string.format('Module "%s" not found',W))return nil end end;local af=thisScript().name;if not af then error("Cannot get the name of the caller script.")end;_G.moduler=function()end;if not useOldMethod then local ag=build(af)if not ag then error("Failed to build the final script.")end;_G.moduler=load else local ah=thisScript()local E=""if sendThroughCommand then E=string.format([[lua_thread.create(function()wait(100)sampProcessChatInput("/moduler ".."%s")thisScript():unload()end)]],ah.name)else E=string.format([[require'lib.moonloader'local a=import'%s'lua_thread.create(function()wait(100)a.load("%s")thisScript():unload()end)]],a:gsub("\\","\\\\"),ah.name)end;local ai=os.tmpname().."_moduler_requestload.lua"local aj=io.open(ai,"wb")aj:write(E)aj:close()local e,f=pcall(function()script.load(ai)end)if forceKill then local ak,al=pcall(function()ah:unload()end)error("_FORCE_KILL_THE_SCRIPT_")else lua_thread.create(function()wait(1)local ak,al=pcall(function()ah:unload()end)end)end;_G.moduler=function(A)local ak,al=pcall(function()ah:unload()end)end end;return _G.moduler
