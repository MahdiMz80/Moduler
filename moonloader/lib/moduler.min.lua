-- moduler library for splitting scripts into the modules and load them anywhere, with no need for changing the structure
-- Made by MahdiMz
-- https://github.com/MahdiMz80/Moduler
-- v2.2

local a=false;local b=true;local c=false;local d=nil;function getLoaderPath()for e,f in pairs(script.list())do if f.name:lower()=="moduler"then return f.path end end;return false end;function loadModuler()local g=getWorkingDirectory().."\\lib\\moduler_loader.lua"if doesFileExist(g)then local h,i=pcall(function()script.load(g)end)if h then d=g end end end;if not a then d=getLoaderPath()if not d then loadModuler()end;assert(d,"Cannot load the moduler loader script.")end;local j={}function string:trim()return self:match("^%s*(.-)%s*$")end;function noExt(k)k=k:gsub("%.+",".")if k:lower():match("%.luac$")then k=k:sub(1,-6)elseif k:lower():match("%.lua$")then k=k:sub(1,-5)end;return k end;function printErr(l)print("{ff7070}(error): {c0c0c0}"..l)end;function extractSubmodule(m,n)m=m:gsub("\r\n","\n"):gsub("\r","\n")local o="%-%-%s*[Mm]oduler:%s*"..n.."%s*\n"local p,q=m:find("^"..o)if not p then p,q=m:find("\n"..o)end;if not p then return nil end;local r=q+1;local s=m:find("\n%-%-%s*[Mm]oduler:%s*[_%w]+%s*\n",r)local t=m:sub(r,s and s-1 or#m)t=t:gsub("^\n+",""):gsub("\n+$","")return t end;function findModulerCalls(u)local v={}local w=1;while true do local x,y,z=u:find('moduler%s*%(%s*["\']([^"\']+)["\']%s*%)',w)if not x then break end;local A=x;while A>1 and u:sub(A-1,A-1):match('[^\r\n]')do A=A-1 end;local B=u:sub(A,x-1)local C=false;if B:match("^%s*%-%-")then C=true end;local D=u:sub(1,x-1)local E=D:match(".*()%-%-%[%[")if E then local F=u:find("%]%]",E)if not F or F>x then C=true end end;if not C then local G=B:match('^([ \t]*)')table.insert(v,{module=z,indent=G})end;w=y+1 end;return v end;function applyIndentation(H,G)local I={}for J in(H.."\n"):gmatch("([^\r\n]*)\r?\n")do table.insert(I,J)end;if#I>0 then local K=nil;for L,J in ipairs(I)do if J:match("%S")then local M=J:match("^([ \t]*)")if not K or#M<#K then K=M end end end;if K and#K>0 then local N={}for L,J in ipairs(I)do if J:sub(1,#K)==K then table.insert(N,J:sub(#K+1))else table.insert(N,J)end end;I=N end end;if G==""then return table.concat(I,"\n")end;local O={}for L,J in ipairs(I)do table.insert(O,G..J)end;return table.concat(O,"\n")end;function build(P)P=noExt(P)local Q=getWorkingDirectory()local R=Q.."/moduler"local S=R.."/"..P;local T=Q.."/"..P..".lua"if not doesFileExist(T)then printErr('Script "'..P..'.lua" not found')return false end;local U=io.open(T,"rb")if not U then printErr("Error opening script: "..P)return false end;local V=U:read("*a")U:close()if#V==0 then printErr(string.format('Script "%s" is empty.',P))return false end;local W=V:sub(1,4)if not W then printErr("No header found in script: "..P)return false end;if W=="\27Lua"or W=="\27LJ"then printErr(string.format('Script "%s" not supported as it is compiled. Use plain lua script.',P))return false end;local X=findModulerCalls(V)if#X==0 then print('No moduler() calls found in "'..P..'"')return true end;print('{44bbff}Moduler: {c0c0c0}Building "'..P..'" with '..#X..' module calls...')j={}local Y={}for L,Z in ipairs(X)do local _,G=Z.module,Z.indent;local z=noExt(_)local n=nil;if z:match("%.",1,true)then local a0={}for a1 in z:gmatch("[^%.]+")do table.insert(a0,a1)end;if#a0>2 then printErr("Submodule nesting too deep: ".._)return false end;z=a0[1]n=#a0==2 and a0[2]:trim()or nil end;local a2=S.."/"..z..".lua"if not doesFileExist(a2)then printErr(string.format('Module "%s" not found for script "%s"',z,P))return false end;local a3=io.open(a2,"rb")if not a3 then printErr(string.format('Error opening module "%s" for script "%s"',z,P))return false end;local m=a3:read("*a")a3:close()if#m==0 then printErr(string.format('Module "%s" for script "%s" is empty.',z,P))return false end;local a4=m:sub(1,4)if not a4 then printErr(string.format('No header found in module "%s" for script "%s"',z,P))return false end;if a4=="\27Lua"or a4=="\27LJ"then printErr(string.format('Module "%s" for script "%s" not supported as it is compiled. Use plain lua module.',z,P))return false end;local a5;if n then a5=extractSubmodule(m,n)if not a5 then printErr(string.format('Submodule "%s" not found in module "%s" for script "%s"',n,z,P))return false end else a5=m end;local a6,a7=loadstring(a5,"@"..z..(n and"."..n or""))if not a6 then printErr(string.format('Syntax error in "%s" for script "%s": %s',_,P,a7))return false end;local a8=applyIndentation(a5,G)table.insert(Y,{marker='moduler%s*%(%s*["\']'.._:gsub("%.","%%%.")..'["\']%s*%)',code="--[[START OF MODULER: ".._.."]]\n"..a8:gsub("%%","%%%%").."\n"..G.."--[[END OF MODULER: ".._.."]]"})if not j[_]then j[_]=a5 end end;V=V:gsub('require%s*%(%s*["\']moduler["\']%s*%)','-- require("moduler") removed')for L,a9 in ipairs(Y)do V=V:gsub(a9.marker,a9.code)end;local aa=R.."\\"..P.."_moduler.lua"local ab=io.open(aa,"wb")if not ab then printErr("Error writing the built script: "..P)return false end;ab:write(V)ab:close()local ac,ad=loadstring(V,P..".lua")if not ac then printErr(string.format('Syntax error in built script "%s": %s',P,ad))return false end;for _,ae in pairs(j)do local af,ag=loadstring(ae,"@".._)if af then j[_]=af else printErr(string.format('Syntax error in "%s": %s',_,ag))j[_]=nil end end;print(string.format("{44bbff}Moduler: {c0c0c0}Loaded %d modules/submodules for '%s'",(function()local ah=0;for L in pairs(j)do ah=ah+1 end;return ah end)(),P))return true end;function load(_)if not _ or _==""then printErr("Invalid module path")return nil end;_=_:trim()local ai=j[_]if ai and type(ai)=="function"then return ai()else printErr(string.format('Module "%s" not found',_))return nil end end;local aj=thisScript().name;if not aj then error("Cannot get the name of the caller script.")end;_G.moduler=function()end;if a then local ak=build(aj)if not ak then error("Failed to build the final script.")end;_G.moduler=load else local al=thisScript()local H=""if c then H=string.format([=[lua_thread.create(function()wait(100)sampProcessChatInput("/moduler ".."%s")thisScript():unload()end)]=],al.name)else H=string.format([=[require'lib.moonloader'local a=import'%s'lua_thread.create(function()wait(100)a.load("%s")thisScript():unload()end)]=],d:gsub("\\","\\\\"),al.name)end;local am=os.tmpname().."_moduler_requestload.lua"local an=io.open(am,"wb")an:write(H)an:close()local h,i=pcall(function()script.load(am)end)if b then local ao,ap=pcall(function()al:unload()end)error("_FORCE_KILL_THE_SCRIPT_")else lua_thread.create(function()wait(1)local ao,ap=pcall(function()al:unload()end)end)end;_G.moduler=function(z)local ao,ap=pcall(function()al:unload()end)end end;return _G.moduler
