script_name("moduler")
script_description("moduler loader")
script_author("MahdiMz")
script_url("https://github.com/MahdiMz80/Moduler")

local a=2;function string:trim()return self:match("^%s*(.-)%s*$")end;function noExt(b)b=b:gsub("%.+",".")if b:lower():match("%.luac$")then b=b:sub(1,-6)elseif b:lower():match("%.lua$")then b=b:sub(1,-5)end;return b end;local c=getWorkingDirectory().."/moduler"if not doesDirectoryExist(c)then createDirectory(c)end;function printErr(d)print("{ff7070}(error): {c0c0c0}"..d)end;function isScrLoaded(e)for f,g in pairs(script.list())do if noExt(g.name:lower():trim())==noExt(e:lower():trim())then return g end end;return false end;function extractSubmodule(h,i)h=h:gsub("\r\n","\n"):gsub("\r","\n")local j="%-%-%s*[Mm]oduler:%s*"..i.."%s*\n"local k,l=h:find("^"..j)if not k then k,l=h:find("\n"..j)end;if not k then return nil end;local m=l+1;local n=h:find("\n%-%-%s*[Mm]oduler:%s*[_%w]+%s*\n",m)local o=h:sub(m,n and n-1 or#h)o=o:gsub("^\n+",""):gsub("\n+$","")return o end;function findModulerCalls(p)local q={}local r=1;while true do local s,t,u=p:find('moduler%s*%(%s*["\']([^"\']+)["\']%s*%)',r)if not s then break end;local v=s;while v>1 and p:sub(v-1,v-1):match('[^\r\n]')do v=v-1 end;local w=p:sub(v,s-1)local x=false;if w:match("^%s*%-%-")then x=true end;local y=p:sub(1,s-1)local z=y:match(".*()%-%-%[%[")if z then local A=p:find("%]%]",z)if not A or A>s then x=true end end;if not x then local B=w:match('^([ \t]*)')table.insert(q,{module=u,indent=B})end;r=t+1 end;return q end;function applyIndentation(C,B)local D={}for E in(C.."\n"):gmatch("([^\r\n]*)\r?\n")do table.insert(D,E)end;if#D>0 then local F=nil;for G,E in ipairs(D)do if E:match("%S")then local H=E:match("^([ \t]*)")if not F or#H<#F then F=H end end end;if F and#F>0 then local I={}for G,E in ipairs(D)do if E:sub(1,#F)==F then table.insert(I,E:sub(#F+1))else table.insert(I,E)end end;D=I end end;if B==""then return table.concat(D,"\n")end;local J={}for G,E in ipairs(D)do table.insert(J,B..E)end;return table.concat(J,"\n")end;function build(e)e=noExt(e)local K=getWorkingDirectory()local c=K.."/moduler"local L=c.."/"..e;local M=K.."/"..e..".lua"if not doesFileExist(M)then printErr('Script "'..e..'.lua" not found')return false end;local N=io.open(M,"rb")if not N then printErr("Error opening script: "..e)return false end;local O=N:read("*a")N:close()if#O==0 then printErr(string.format('Script "%s" is empty.',e))return false end;local P=O:sub(1,4)if not P then printErr("No header found in script: "..e)return false end;if P=="\27Lua"or P=="\27LJ"then printErr(string.format('Script "%s" not supported as it is compiled. Use plain lua script.',e))return false end;local Q=findModulerCalls(O)if#Q==0 then print('No moduler() calls found in "'..e..'"')local R,S=loadstring(O,e..".lua")if not R then printErr("Syntax error in "..e..": "..S)return false end;local T,U=pcall(R)if not T then printErr(string.format('Error executing script: "%s": %s',e,U))return false end;return true end;print('{44bbff}Moduler: {c0c0c0}Building "'..e..'" with '..#Q..' module calls...')local V={}for G,W in ipairs(Q)do local X,B=W.module,W.indent;local u=noExt(X)local i=nil;if u:match("%.",1,true)then local Y={}for Z in u:gmatch("[^%.]+")do table.insert(Y,Z)end;if#Y>2 then printErr("Submodule nesting too deep: "..X)return false end;u=Y[1]i=#Y==2 and Y[2]:trim()or nil end;local _=L.."/"..u..".lua"if not doesFileExist(_)then printErr(string.format('Module "%s" not found for script "%s"',u,e))return false end;local a0=io.open(_,"rb")if not a0 then printErr(string.format('Error opening module "%s" for script "%s"',u,e))return false end;local h=a0:read("*a")a0:close()if#h==0 then printErr(string.format('Module "%s" for script "%s" is empty.',u,e))return false end;local a1=h:sub(1,4)if not a1 then printErr(string.format('No header found in module "%s" for script "%s"',u,e))return false end;if a1=="\27Lua"or a1=="\27LJ"then printErr(string.format('Module "%s" for script "%s" not supported as it is compiled. Use plain lua module.',u,e))return false end;local a2;if i then a2=extractSubmodule(h,i)if not a2 then printErr(string.format('Submodule "%s" not found in module "%s" for script "%s"',i,u,e))return false end else a2=h end;local a3,a4=loadstring(a2,"@"..u..(i and"."..i or""))if not a3 then printErr(string.format('Syntax error in "%s" for script "%s": %s',X,e,a4))return false end;local a5=applyIndentation(a2,B)table.insert(V,{marker='moduler%s*%(%s*["\']'..X:gsub("%.","%%%.")..'["\']%s*%)',code="--[[START OF MODULER: "..X.."]]\n"..a5:gsub("%%","%%%%").."\n"..B.."--[[END OF MODULER: "..X.."]]"})end;O=O:gsub('require%s*%(%s*["\']moduler["\']%s*%)','-- require("moduler") removed')for G,a6 in ipairs(V)do O=O:gsub(a6.marker,a6.code)end;local a7=c.."\\"..e.."_moduler.lua"local a8=io.open(a7,"wb")if not a8 then printErr("Error writing the built script: "..e)return false end;a8:write(O)a8:close()local a9,aa=loadstring(O,e..".lua")if not a9 then printErr(string.format('Syntax error in built script "%s": %s',e,aa))return false end;local ab,ac=pcall(function()script.load(a7)end)if not ab then printErr("Error loading the built "..e..": "..ac)return false end;return true end;local ad=0;function _load(e)ad=ad+1;if ad>a then return false end;local ae=isScrLoaded(e)if ae then local T=pcall(function()ae:unload()end)if not T then printErr("Failed Unloading: "..e)return false end;local af,ag=pcall(lua_thread.create,function()wait(100)_load(e)end)return false end;local K=getWorkingDirectory()local c=K.."/moduler"local L=c.."/"..e;if not doesDirectoryExist(c)then createDirectory(c)printErr('No Modules found for "'..e..'"')return false end;if not doesDirectoryExist(L)then printErr('No Modules found for "'..e..'"')return false end;return build(e)end;function load(e)ad=0;local e=e and noExt(e:trim())or nil;if not e or e==""or e:lower()=="moduler"then return false end;return _load(e)end;function main()if not isSampLoaded()or not isSampfuncsLoaded()then return end;while not isSampAvailable()do wait(0)end;sampRegisterChatCommand("moduler",function(e)local e=e and noExt(e:trim())or nil;if not e or e==""or e:lower()=="moduler"then return false end;load(e)end)while true do wait(0)end end;EXPORTS={load=load}
