script_name("moduler")
script_description("moduler loader")
script_author("MahdiMz")
script_url("https://github.com/MahdiMz80/Moduler")

local a=2;function string:trim()return self:match("^%s*(.-)%s*$")end;function noExt(b)b=b:gsub("%.+",".")if b:lower():match("%.luac$")then b=b:sub(1,-6)elseif b:lower():match("%.lua$")then b=b:sub(1,-5)end;return b end;local c=getWorkingDirectory().."/moduler"if not doesDirectoryExist(c)then createDirectory(c)end;function printErr(d)print("{ff7070}(error): {c0c0c0}"..d)end;function isScrLoaded(e)for f,g in pairs(script.list())do if noExt(g.name:lower():trim())==noExt(e:lower():trim())then return g end end;return false end;function extractSubmodule(h,i)h=h:gsub("\r\n","\n"):gsub("\r","\n")local j="%-%-%s*[Mm]oduler:%s*"..i.."%s*\n"local k,l=h:find("^"..j)if not k then k,l=h:find("\n"..j)end;if not k then return nil end;local m=l+1;local n=h:find("\n%-%-%s*[Mm]oduler:%s*[_%w]+%s*\n",m)local o=h:sub(m,n and n-1 or#h)o=o:gsub("^\n+",""):gsub("\n+$","")return o end;function findModulerCalls(p)local q={}local r={}local s=1;while true do local k=p:find("%-%-%[%[",s)if not k then break end;local n=p:find("%]%]",k+4)if n then table.insert(r,{s=k,e=n+1})s=n+2 else break end end;local function t(u)for v,w in ipairs(r)do if u>=w.s and u<=w.e then return true end end;return false end;for x,y in p:gmatch('(moduler%s*%(%s*["\']([^"\']+)["\']%s*%))')do local z=p:find(x,1,true)if z and not t(z)then local A=p:sub(1,z):match(".*\n()")or 1;local B=p:sub(A,z-1)if not B:match("^%s*%-%-")then local C=B:match('^([ \t]*)')table.insert(q,{module=y,indent=C or""})end end end;return q end;function applyIndentation(D,C)local E={}for F in(D.."\n"):gmatch("([^\r\n]*)\r?\n")do table.insert(E,F)end;if#E>0 then local G=nil;for v,F in ipairs(E)do if F:match("%S")then local H=F:match("^([ \t]*)")if not G or#H<#G then G=H end end end;if G and#G>0 then local I={}for v,F in ipairs(E)do if F:sub(1,#G)==G then table.insert(I,F:sub(#G+1))else table.insert(I,F)end end;E=I end end;if C==""then return table.concat(E,"\n")end;local J={}for v,F in ipairs(E)do table.insert(J,C..F)end;return table.concat(J,"\n")end;function build(e)e=noExt(e)local K=getWorkingDirectory()local c=K.."/moduler"local L=c.."/"..e;local M=K.."/"..e..".lua"if not doesFileExist(M)then printErr('Script "'..e..'.lua" not found')return false end;local N=io.open(M,"rb")if not N then printErr("Error opening script: "..e)return false end;local O=N:read("*a")N:close()if#O==0 then printErr(string.format('Script "%s" is empty.',e))return false end;local P=O:sub(1,4)if not P then printErr("No header found in script: "..e)return false end;if P=="\27Lua"or P=="\27LJ"then printErr(string.format('Script "%s" not supported as it is compiled. Use plain lua script.',e))return false end;local Q=findModulerCalls(O)if#Q==0 then print('No moduler() calls found in "'..e..'"')local R,S=loadstring(O,e..".lua")if not R then printErr("Syntax error in "..e..": "..S)return false end;local T,U=pcall(R)if not T then printErr(string.format('Error executing script: "%s": %s',e,U))return false end;return true end;print('{44bbff}Moduler: {c0c0c0}Building "'..e..'" with '..#Q..' module calls...')local V={}for v,W in ipairs(Q)do local X,C=W.module,W.indent;local y=noExt(X)local i=nil;if y:match("%.",1,true)then local Y={}for u in y:gmatch("[^%.]+")do table.insert(Y,u)end;if#Y>2 then printErr("Submodule nesting too deep: "..X)return false end;y=Y[1]i=#Y==2 and Y[2]:trim()or nil end;local Z=L.."/"..y..".lua"if not doesFileExist(Z)then printErr(string.format('Module "%s" not found for script "%s"',y,e))return false end;local _=io.open(Z,"rb")if not _ then printErr(string.format('Error opening module "%s" for script "%s"',y,e))return false end;local h=_:read("*a")_:close()if#h==0 then printErr(string.format('Module "%s" for script "%s" is empty.',y,e))return false end;local a0=h:sub(1,4)if not a0 then printErr(string.format('No header found in module "%s" for script "%s"',y,e))return false end;if a0=="\27Lua"or a0=="\27LJ"then printErr(string.format('Module "%s" for script "%s" not supported as it is compiled. Use plain lua module.',y,e))return false end;local a1;if i then a1=extractSubmodule(h,i)if not a1 then printErr(string.format('Submodule "%s" not found in module "%s" for script "%s"',i,y,e))return false end else a1=h end;local a2,a3=loadstring(a1,"@"..y..(i and"."..i or""))if not a2 then printErr(string.format('Syntax error in "%s" for script "%s": %s',X,e,a3))return false end;local a4=applyIndentation(a1,C)table.insert(V,{marker='moduler%s*%(%s*["\']'..X:gsub("%.","%%%.")..'["\']%s*%)',code="--[[START OF MODULER: "..X.."]]\n"..a4:gsub("%%","%%%%").."\n"..C.."--[[END OF MODULER: "..X.."]]"})end;O=O:gsub('require%s*%(%s*["\']moduler["\']%s*%)','-- require("moduler") removed')for v,a5 in ipairs(V)do O=O:gsub(a5.marker,a5.code)end;local a6=c.."\\"..e.."_moduler.lua"local a7=io.open(a6,"wb")if not a7 then printErr("Error writing the built script: "..e)return false end;a7:write(O)a7:close()local a8,a9=loadstring(O,e..".lua")if not a8 then printErr(string.format('Syntax error in built script "%s": %s',e,a9))return false end;local aa,ab=pcall(function()script.load(a6)end)if not aa then printErr("Error loading the built "..e..": "..ab)return false end;return true end;local ac=0;function _load(e)ac=ac+1;if ac>a then return false end;local ad=isScrLoaded(e)if ad then local T=pcall(function()ad:unload()end)if not T then printErr("Failed Unloading: "..e)return false end;local ae,af=pcall(lua_thread.create,function()wait(100)_load(e)end)return false end;local K=getWorkingDirectory()local c=K.."/moduler"local L=c.."/"..e;if not doesDirectoryExist(c)then createDirectory(c)printErr('No Modules found for "'..e..'"')return false end;if not doesDirectoryExist(L)then printErr('No Modules found for "'..e..'"')return false end;return build(e)end;function load(e)ac=0;local e=e and noExt(e:trim())or nil;if not e or e==""or e:lower()=="moduler"then return false end;return _load(e)end;function main()if not isSampLoaded()or not isSampfuncsLoaded()then return end;while not isSampAvailable()do wait(0)end;sampRegisterChatCommand("moduler",function(e)local e=e and noExt(e:trim())or nil;if not e or e==""or e:lower()=="moduler"then return false end;load(e)end)while true do wait(0)end end;EXPORTS={load=load}
