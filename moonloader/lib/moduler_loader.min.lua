script_name("moduler")script_description("moduler loader")script_author("MahdiMz")script_url("https://github.com/MahdiMz80/Moduler")local a=2;function string:trim()return self:match("^%s*(.-)%s*$")end;function noExt(b)b=b:gsub("%.+",".")if b:lower():match("%.luac$")then b=b:sub(1,-6)elseif b:lower():match("%.lua$")then b=b:sub(1,-5)end;return b end;local c=getWorkingDirectory().."/moduler"if not doesDirectoryExist(c)then createDirectory(c)end;function printErr(d)print("{ff7070}(error): {c0c0c0}"..d)end;function isScrLoaded(e)for f,g in pairs(script.list())do if noExt(g.name:lower():trim())==noExt(e:lower():trim())then return g end end;return false end;function extractSubmodule(h,i)local j={"local%s+function%s+"..i.."%s*%b()","function%s+"..i.."%s*%b()","local%s+"..i.."%s*=%s*function%s*%b()",i.."%s*=%s*function%s*%b()"}local k;for l,m in ipairs(j)do k=h:find(m)if k then break end end;if not k then return nil end;local n=h:find("%b()",k)if not n then return nil end;local l,n=h:find("%b()",k)n=n+1;local o,p,q=k,0,false;while o<=#h do local r,s=h:match("^([%a_][%w_]*)()",o)if r then if r=="function"or r=="do"or r=="if"or r=="for"or r=="while"or r=="repeat"then p=p+1;if r=="function"then q=true end;o=s elseif r=="end"then if q then p=p-1;if p==0 then local t=h:sub(n,o-1):match("^[\r\n]*(.-)[ \t\r\n]*$")return t end end;o=s elseif r=="until"then p=p-1;o=s else o=s end else o=o+1 end end;return nil end;function findModulerCalls(u)local v={}local o=1;while true do local w,x,y=u:find('moduler%s*%(%s*["\']([^"\']+)["\']%s*%)',o)if not w then break end;local z=w;while z>1 and u:sub(z-1,z-1):match('[^\r\n]')do z=z-1 end;local A=u:sub(z)local B=A:match('^([ \t]*)')table.insert(v,{module=y,indent=B})o=x+1 end;return v end;function applyIndentation(C,B)local D={}for E in C:gmatch("[^\r\n]+")do table.insert(D,E)end;if#D>0 then local F=nil;for l,E in ipairs(D)do if E:match("%S")then local G=E:match("^([ \t]*)")if not F or#G<#F then F=G end end end;if F and#F>0 then local H={}for l,E in ipairs(D)do if E:sub(1,#F)==F then table.insert(H,E:sub(#F+1))else table.insert(H,E)end end;D=H end end;if B==""then return table.concat(D,"\n")end;local I={}for l,E in ipairs(D)do table.insert(I,B..E)end;return table.concat(I,"\n")end;function build(e)e=noExt(e)local J=getWorkingDirectory()local c=J.."/moduler"local K=c.."/"..e;local L=J.."/"..e..".lua"if not doesFileExist(L)then printErr('Script "'..e..'.lua" not found')return false end;local M=io.open(L,"rb")if not M then printErr("Error opening script: "..e)return false end;local N=M:read("*a")M:close()if#N==0 then printErr(string.format('Script "%s" is empty.',e))return false end;local O=N:sub(1,4)if not O then printErr("No header found in script: "..e)return false end;if O=="\27Lua"or O=="\27LJ"then printErr(string.format('Script "%s" not supported as it is compiled. Use plain lua script.',e))return false end;local P=findModulerCalls(N)if#P==0 then print('No moduler() calls found in "'..e..'"')local Q,R=loadstring(N,e..".lua")if not Q then printErr("Syntax error in "..e..": "..R)return false end;local S,T=pcall(Q)if not S then printErr(string.format('Error executing script: "%s": %s',e,T))return false end;return true end;print('{44bbff}Moduler: {c0c0c0}Building "'..e..'" with '..#P..' module calls...')local U={}for l,V in ipairs(P)do local W,B=V.module,V.indent;local y=noExt(W)local i=nil;if y:match("%.",1,true)then local X={}for Y in y:gmatch("[^%.]+")do table.insert(X,Y)end;if#X>2 then printErr("Submodule nesting too deep: "..W)return false end;y=X[1]i=#X==2 and X[2]:trim()or nil end;local Z=K.."/"..y..".lua"if not doesFileExist(Z)then printErr(string.format('Module "%s" not found for script "%s"',y,e))return false end;local _=io.open(Z,"rb")if not _ then printErr(string.format('Error opening module "%s" for script "%s"',y,e))return false end;local h=_:read("*a")_:close()if#h==0 then printErr(string.format('Module "%s" for script "%s" is empty.',y,e))return false end;local a0=h:sub(1,4)if not a0 then printErr(string.format('No header found in module "%s" for script "%s"',y,e))return false end;if a0=="\27Lua"or a0=="\27LJ"then printErr(string.format('Module "%s" for script "%s" not supported as it is compiled. Use plain lua module.',y,e))return false end;local a1;if i then a1=extractSubmodule(h,i)if not a1 then printErr(string.format('Submodule "%s" not found in module "%s" for script "%s"',i,y,e))return false end else a1=h end;local a2,a3=loadstring(a1,"@"..y..(i and"."..i or""))if not a2 then printErr(string.format('Syntax error in "%s" for script "%s": %s',W,e,a3))return false end;local a4=applyIndentation(a1,B)table.insert(U,{marker='moduler%s*%(%s*["\']'..W:gsub("%.","%%%.")..'["\']%s*%)',code=string.format("--[[START OF MODULER: %s]]\n%s\n%s--[[END OF MODULER: %s]]",W,a4,B,W)})end;for l,a5 in ipairs(U)do N=N:gsub(a5.marker,a5.code)end;N=N:gsub('require%s*%(%s*["\']moduler["\']%s*%)','-- require("moduler") removed')local a6,a7=loadstring(N,e..".lua")if not a6 then printErr(string.format('Syntax error in built script "%s": %s',e,a7))return false end;local a8=c.."\\"..e.."_moduler.lua"local a9=io.open(a8,"wb")if not a9 then printErr("Error writing the built script: "..e)return false end;a9:write(N)a9:close()local aa,ab=pcall(function()script.load(a8)end)if not aa then printErr("Error loading the built "..e..": "..ab)return false end;print('{44bbff}Moduler: {c0c0c0}Successfully built and loaded "'..e..'"')return true end;local ac=0;function _load(e)ac=ac+1;if ac>a then return false end;local ad=isScrLoaded(e)if ad then local S=pcall(function()ad:unload()end)if not S then printErr("Failed Unloading: "..e)return false end;local ae,af=pcall(lua_thread.create,function()wait(100)_load(e)end)return false end;local J=getWorkingDirectory()local c=J.."/moduler"local K=c.."/"..e;if not doesDirectoryExist(c)then createDirectory(c)printErr('No Modules found for "'..e..'"')return false end;if not doesDirectoryExist(K)then printErr('No Modules found for "'..e..'"')return false end;return build(e)end;function load(e)ac=0;local e=e and noExt(e:trim())or nil;if not e or e==""or e:lower()=="moduler"then return false end;return _load(e)end;function main()if not isSampLoaded()or not isSampfuncsLoaded()then return end;while not isSampAvailable()do wait(0)end;sampRegisterChatCommand("moduler",function(e)local e=e and noExt(e:trim())or nil;if not e or e==""or e:lower()=="moduler"then return false end;load(e)end)while true do wait(0)end end;EXPORTS={load=load}
